1. Concepts. Anything that needs to be understood in flexible ways. Not just stuff that needs to be memorized.

    **ML/DL Fundamentals**
    1. Debugging
    2. Deep Learning
    3. Loss functions & optimizers (SGD, Adam, learning rate schedules)
    4. Regularization techniques (dropout, batch norm, L1/L2)
    5. Hyperparameter tuning strategies
    6. Transfer learning / fine-tuning
    7. Neural network architectures (CNNs, RNNs, Transformers)
    8. Attention mechanisms
    9. Bias-variance tradeoff

    **Domain Areas**
    10. Recommendation Systems
    11. NLP
    12. Computer Vision
    13. Reinforcement Learning

    **ML Engineer Concepts**
    14. Distributed Training / Distributed Computing
    15. MLOps
    16. HPC Infrastructure
    17. Model Optimization
    18. Model serving / inference optimization
    19. Batch vs real-time inference
    20. Model monitoring (drift detection, performance decay)
    21. Data pipelines for ML

    **Data Scientist (Consumer) Concepts**
    22. A/B testing
    23. Causal inference
    24. Statistical hypothesis testing
    25. Experiment design
    26. Feature engineering

    **Research/Advanced (DS-ML)**
    27. Generative models (GANs, VAEs, Diffusion models)
    28. Self-supervised learning
    29. LLM fine-tuning (LoRA, RLHF)

    **System Design**
    30. ML system design patterns
    31. Latency vs throughput tradeoffs
    32. Scalability for ML systems

    **Software Engineering**
    33. Context efficiency
    34. Version control
        1. Worktrees
        2. Pull requests
        3. Pushing
    35. Object oriented programming
    36. CLIs
    37. MCPs
    38. Deployment, hosting
    39. Agents calling Subagents
    40. IDES
    41. Cursor / Codex / Claude Code
    42. Code review
    43. Design choices at beginning of project that will be hard to change later
    44. Cloud computing
    45. Best way to get software role ([here](https://youtu.be/w7o355LsM9I?t=1251))
    46. Type checking
    47. Type safety 
2. Facts. Stuff you need to memorize.
    1. Use cases, strengths, and weaknesses of each LLM and agent.
    2. Use cases, strengths, and weaknesses of each programming language 
    3. Security vulnerabilities 
    4. All the acronyms (CLI, SDK, etc.)
    5. Git terminology 
    6. Available softwares, libraries, connections to improve everything else
    7. Job positions 
    8. List of important skills and problems to solve, according to startup founders, hiring managers, and executives.
    9. What npm does
    10. Best way to type check code
    11. OOP stuff (class, method, object, attribute)
3. Procedures
    1. **Python**
    2. **C++**
    3. **PyTorch**
    4. **TensorFlow**
    5. **JAX**
    6. **CUDA**
    7. **Kubernetes**
    8. **Docker**
    8. Using VSCode (shortcuts, settings, tools, interface)
    9. Downloading repos
    10. Copying remote files into a repo
    11. Creating a new repo
    12. Create a new worktree
    13. Having multiple work trees and having agents in each, then merging them together.
    14. Agent workflows
    15. Debugging agents 
    16. Setting up cloud computing for ML / RL
    17. Writing a great readme
    18. Creating a compelling portfolio 
    19. Reaching out for coffee chats
    20. Contributing to existing code bases
    21. Getting agents to write type checked code
    22. Code review with Greptile
    23. Being useful by joining programmer discords and providing people with solutions / resources to solve the problems they ask.
    24. ‘Spending time in github issues tab’ [here](https://youtu.be/w7o355LsM9I?t=2613)
    25. Answering questions in Theo’s discord or on X ([here](https://youtu.be/w7o355LsM9I?t=2613))
    26. Attending conferences and job fairs)
    27. Outreach to recruiters.
